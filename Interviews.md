# Java concurrent

1. 上下文切换
    1. 如何减少上下文切换
        1. 无锁并发编程
        2. CAS算法
        3. 使用最少线程
        4. 使用协程
2. 死锁
    1. 两个线程相互持有对方的monitor并等待自己的monitor释放会造成死锁
    2. 避免死锁的常见方法
        1. 避免一个线程同时获取多个锁
        2. 避免一个线程在锁内同时占用多个资源,尽量保证一个锁占用一个资源
        3. 尝试使用定时锁,使用tryLock(timeout)来替代使用内部锁
        4. 对数据库锁,加锁和解锁必须在一个数据库连接里,否则会出现解锁失败的情况

# Java 并发底层实现原理

1. volatile的定义与实现原理

如果一个字段被声明成volatile,Java线程内存模型确保所有线程看到的这个变量的值是一致的.

一个有volatile变量修饰的共享变量进行写操作时,在汇编时会添加lock前缀指令,该指令会引发两件事情

1) 将当前处理器的缓存行的数据写回到系统内存

2) 这个写回内存的操作会使在其他cpu里缓存了该内存地址的数据无效

volatile的两条实现原则

1) Lock前缀指令会引起处理器缓存写回到内存中.

2)一个处理器的缓存写回到内存中会导致其他处理器的缓存无效

2. synchronized

* 对于普通同步方式,锁是当前实例对象
* 对于静态同步方法,锁是当前类的class对象
* 对于同步代码块,锁是Synchronized中配置的对象

JVM中代码块同步使用monitorenter和monitorexist指令实现;

锁的竞争升级

无锁,偏向锁,轻量锁,重量锁

大多数情况下,锁不存在多线程竞争,而是总由同一线程多次获取,为了让线程获取锁的代价更低,引入了偏向锁.



1. 偏向锁:

当一个线程访问同步代码块并获取到锁时,会在对象头和栈帧中的锁记录中存储偏向的线程ID,以后该线程在进入和退出同步代码块时不需要进行cas操作来加锁和解锁,只需要测试对象头中是MarkWord是否存在指向当前线程的偏向锁.如果成功表示获取了锁,如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。

(1)偏向锁的撤销

2. 轻量锁



原子操作的实现原理

处理器保证从系统内存中读取或写入一个字节是原子的,但不自动保证复杂操作的原子性 如:跨总线宽度,跨多个缓存行,跨页表的访问.

处理器提供两个机制保证复杂内存操作的原子性

(1)使用总线锁保证原子性

(2)缓存锁定

两种情况下处理器不会使用缓存锁定

(1) 当操作的数据不能被缓存到处理器内部,或操作数据跨多个缓存行,处理器会调用总线锁定

(1)不支持缓存锁定的处理器,直接调用总线锁定



Java如何实现原子操作

(1)使用CAS自旋

(2)CAS实现原子操作的三大问题

* ABA问题 AtomicStampedReference
* 长时间循环开销大 
* 只能保证一个共享变量的原子操作

